---
title: "CP_RNAseq"
output: html_document
date: "2023-06-27"
---

```{r setup, include=FALSE}

knitr::opts_knit$set(root.dir = '~/Documents/GitHub/Cross_pHox/')

library(edgeR)
library(DESeq2)
library(tidyverse)
library(arrayQualityMetrics)
library(pheatmap)
library(ape)
library(vegan)
library(reshape2)
library(Rmisc)
library(mediation)
library(ggforce)
library(ggpubr)
library(lme4)
library(nadiv)
library(Matrix)
library(lme4qtl)
library(brms)
library(bayestestR)
library(ggExtra)
library(GenomicRanges)
library(lmtest)

```

#Tests of differential expression

```{r}

# Read in and wrangle featureCounts output
featureCounts_df <- read.table("comb_featureCounts.txt")
colnames(featureCounts_df) <- featureCounts_df[1,]
featureCounts_df <- featureCounts_df[-1, ] 

# Make gene id matrix rowname
row.names(featureCounts_df) <- featureCounts_df$Geneid

# Remove unnecessary columns
featureCounts_df <- subset(featureCounts_df,
                           select = -c(Geneid))

# Simplify column names
colnames(featureCounts_df) <- gsub("_RNA_.*", "",
                                   gsub("/home/snbogan/Cross_pHox/hisat2_alignments/to_count/",
                                        "", colnames(featureCounts_df)))

# Remove outliers
featureCounts_df <- featureCounts_df[, !(colnames(featureCounts_df) %in% 
                                           c("U33_U1", "U34_U1"))]

# Create parental treatment variable
Par = as.vector(sapply(colnames(featureCounts_df), 
                       function(col) substr(col, 1, 1)))

# Create developmental treatment variable
Dev = as.vector(gsub(".*_", "",
                     gsub("[0-9]", "", 
                          colnames(featureCounts_df))))

# Create dam variable
parts <- gsub("_.*", "", colnames(featureCounts_df))

# Extract the first number
first_number <- as.numeric(gsub("[^0-9]", "", parts))

# Set Dam and Sire objects
split_numbers <- function(numbers) {
  first_digits <- vector("numeric", length(numbers))
  second_digits <- vector("numeric", length(numbers))
  
  for (i in 1:length(numbers)) {
    number <- as.character(numbers[i])
    
    if (nchar(number) %% 2 == 0) {
      first_digits[i] <- as.numeric(substr(number, 1, nchar(number) / 2))
      second_digits[i] <- as.numeric(substr(number, nchar(number) / 2 + 1, nchar(number)))
    } else {
      first_digits[i] <- as.numeric(substr(number, 1, (nchar(number) + 1) / 2 - 1))
      second_digits[i] <- as.numeric(substr(number, (nchar(number) + 1) / 2, nchar(number)))
    }
  }
  
  return(list(first_digits = first_digits, second_digits = second_digits))
}

# Example usage
split_result <- split_numbers(first_number)

Dam = split_result$first_digits

# Create sire variable
Sire = split_result$second_digits

# Create df of predictor variables
targets_gc <- data.frame(Par = Par,
                         Dev = Dev,
                         Dam = Dam,
                         Sire = Sire)

targets_gc$grouping <- paste( targets_gc$Par, 
                             targets_gc$Dev,
                             sep="_" )

# Round counts (if necessary) for use in edgeR
data_input_gc <- sapply(featureCounts_df,as.numeric)

row.names(data_input_gc) <- row.names(featureCounts_df)

data_input_gc <- as.data.frame(round(data_input_gc))

```

```{r}

# Make DGElist
DGEList <- DGEList(counts = data_input_gc, 
                   group = targets_gc$grouping, 
                  remove.zeros = T)

# Let's remove genes with less then 0.5 cpm (this is ~10 counts in the count file) in no fewer then 9 samples
DGEList_keep <- rowSums(cpm(DGEList) > 0.5) >= 60

# How many genes are removed by read count filter?
table(DGEList_keep)

# Filter and set keep.lib.sizes = F to have R recalculate library sizes after filtering
DGEList <- DGEList[DGEList_keep, 
                   keep.lib.sizes = FALSE]

# Create library size normalization factors
DGEList <- calcNormFactors(DGEList)


# CPM conversion and log^2 transformation of read counts
DGEList_log <- cpm(DGEList,
                   log = TRUE, 
                   prior.count = 2)

# MDS of normalized gene read counts
MDS <- plotMDS(DGEList_log)

# Print MDS plot
MDS

```

```{r}

#PCA
# Export pcoa loadings
dds.pcoa = pcoa(vegdist(t(DGEList_log),
                          method = "euclidean") / 1000)

# Create df of MDS vector loading
scores <- dds.pcoa$vectors

## Plot pcoa loadings of each sample, groouped by time point and pCO2 treatment

# Calculate % variation explained by each eigenvector
percent <- dds.pcoa$values$Eigenvalues
cumulative_percent_variance <- (percent / sum( percent)) * 100

# Prepare information for pcoa plot, then plot

color <- c("#440154FF",
         "#33638DFF",
         "#3CBB75FF",
         "#FDE725FF")
         
par(mfrow = c(1, 1))

plot(
  scores[, 1],
  scores[, 2],
  cex = .5,
  cex.axis = 1,
  cex.lab = 1.25,
  xlab = paste("PC1, ", round(cumulative_percent_variance[1], 2), "%"),
  ylab = paste("PC2, ", round(cumulative_percent_variance[2], 2), "%")
  )

# Add visual groupings to pcoa plot
ordihull(
  scores,
  as.factor(targets_gc$grouping),
  border = NULL,
  lty = 2,
  lwd = .5,
  label = F,
  col = color,
  draw = "polygon",
  alpha = 100,
  cex = .5
  )

ordispider(scores, as.factor(targets_gc$grouping), 
           label = T, col = color, ) # Vectors connecting samples in same pCO2 x time group

N_N <- as.data.frame(scores)[targets_gc$grouping == "N_N", ][chull(as.data.frame(scores)[targets_gc$grouping == 
    "N_N", c("Axis.1", "Axis.2")]), ]  # hull values for grp N_N

N_U <- as.data.frame(scores)[targets_gc$grouping == "N_U", ][chull(as.data.frame(scores)[targets_gc$grouping == 
    "N_U", c("Axis.1", "Axis.2")]), ]  # hull values for grp N_U

U_N <- as.data.frame(scores)[targets_gc$grouping == "U_N", ][chull(as.data.frame(scores)[targets_gc$grouping == 
    "U_N", c("Axis.1", "Axis.2")]), ]  # hull values for grp U_N

U_U <- as.data.frame(scores)[targets_gc$grouping == "U_U", ][chull(as.data.frame(scores)[targets_gc$grouping == 
    "U_U", c("Axis.1", "Axis.2")]), ]  # hull values for grp U_U

N_N$Group <- "N_N"
N_U$Group <- "N_U"
U_N$Group <- "U_N"
U_U$Group <- "U_U"

hull.data <- rbind(N_N, N_U, U_N, U_U)  #combine groups
hull.data$Par <- gsub("_.*", "", hull.data$Group)

scores_df <- as.data.frame(scores)
scores_df$Sibship <- gsub("_.*", "", row.names(scores_df))
scores_df$Par <- as.vector(sapply(scores_df$Sibship, 
                       function(col) substr(col, 1, 1)))

scores_df$Par <- as.vector(sapply(row.names(scores_df), 
                       function(col) substr(col, 1, 1)))

Fig2A <- ggplot(data = scores_df, 
                aes(x = Axis.1, y = Axis.2)) +
  geom_polygon(data=hull.data, aes(x = Axis.1, y = Axis.2, fill = Group),
               alpha=0.33) + # add the convex hulls
  geom_bspline(data = filter(scores_df, row.names(scores_df) != 
                               c("U33_N1", "U34_N1")),
               aes(group = Sibship,
                   alpha = stat(index), size = after_stat(index)), 
               type = "clamped", color = "black") +
  geom_point(aes(color = targets_gc$grouping,
                 shape = targets_gc$grouping), size = 2, alpha = 1) +
  scale_color_viridis_d() +
  scale_fill_viridis_d(guide = "none") +
  theme_classic(base_size = 20, base_rect_size = 0) +
  facet_wrap(~Par) +
  scale_shape_manual(values = c(NA,16,NA,16), guide = "none") +
  scale_size_continuous(range = c(0,1), guide = "none") +
  scale_alpha_continuous(range = c(0.1,.5), guide = "none") +
  labs(x = "PC1, 14.48%", y = "PC2, 9.22%", color = "Treatment")

Fig2A 

```

#Outlier detection

```{r}

# Create DESeq2 object required for arrayqualitymetrics
counts_df <- as.data.frame(gene_counts_matrix)

dds <- DESeqDataSetFromMatrix(counts_df,
                              colData = targets_gc,
                              design = formula(~ 1 + Par + Dev))

# Filter DESeq object
dds_keep <- rowSums(cpm(dds) > 0.5) >= 60
dds <- dds[dds_keep]

# Outlier tests
vsd <- varianceStabilizingTransformation(dds, blind=TRUE)

e <- ExpressionSet(assay(vsd), AnnotatedDataFrame(as.data.frame(colData(vsd))))

arrayQualityMetrics(e, intgroup=c("Par","Dev"), force=T)

```


```{r}
# Export DGEList_keep
save(DGEList_keep,
     file = "DGEList_keep.Rdata")

```

```{r}

# Create model design that includes maternal and developmental effects and set intercept to 0
design_multi_gc <- model.matrix(~0 + Par + Dev)

# Filter and normalize count matrix input
gene_counts_matrix <- as.matrix(data_input_gc)

DGEList <- DGEList(counts = gene_counts_matrix, 
                   group = targets_gc$grouping, 
                   remove.zeros = T)

DGEList <- DGEList[DGEList_keep, 
                   keep.lib.sizes = FALSE]

DGEList <- calcNormFactors(DGEList)

# Estmate mean dispersal for use in plotting common dispersal against tagwise dispersal
DGEList <- estimateGLMCommonDisp(DGEList, 
                                 design_multi_gc)

# Estmate robust, Bayesian dispersal per gene for estimating regression parameters for glmQL and differential expression
DGEList <- estimateGLMRobustDisp(DGEList, 
                                 design_multi_gc) 

# Plot tagwise dispersal and impose w/mean dispersal and trendline
plotBCV(DGEList) 

# Fit a robust, multifactorial quasi-likelihood glm to normalized read counts
fit_gc <- glmQLFit(DGEList, 
                   design_multi_gc, 
                   robust = TRUE)

# Plot shrinkage of Bayesian quasi-likelihood dispersion to visualize stastical power of DE analysis
plotQLDisp(fit_gc) # High shrinkage / high statistical power across DE tests

```

```{r}

## Pairwise comparison of parental differential expression

# Design contrast between samples based on maternal effect
#colnames(design_multi_gc) <- c("ParN", "ParU", "DevU", ""ParU_DevU")
con_Parent <- makeContrasts(con_Par_cons = ParU - ParN,
                            levels = design_multi_gc)

# Apply quasi-likelihood F test to incorporate Bayesian tagwise dispersion estimates as parameter for DEG analysis
parental_QLFT <- glmQLFTest(fit_gc, 
                            contrast = con_Parent)

# Plot maternal logFC across logCPM (fdr < 0.05)
plotMD(parental_QLFT)

# How many significant DEGs? 2405
summary(decideTestsDGE(parental_QLFT, 
                       adjust.method = "fdr",
                       p.value = 0.05))

# Filter for significance and logFC cutoff (doubling of fold change or logFC of 1)
parental_QLFT_cutoff <- topTags(parental_QLFT, 
                                n = (1539 + 1582), 
                                adjust.method = "fdr",
                                p.value = 0.05)

# Create df of logFC and sign cutoff DEGs
parental_QLFT_cutoff_df <- data.frame(parental_QLFT_cutoff$table)
parental_QLFT_fc_cutoff_df <- parental_QLFT_cutoff_df[!(abs( parental_QLFT_cutoff_df$logFC) < 1),]

# Count total DEGs with logFC cutoff
nrow(parental_QLFT_cutoff_df) # Without logFC cutoff = 3027 DEGs
nrow(parental_QLFT_fc_cutoff_df) # With logFC cutoff = 79 DEGs

```

```{r}

## Pairwise comparison of developmental differential expression

# Pairwise comparison of developmental differential expression
con_Dev <- makeContrasts(con_Dev_cons = DevU, 
                         levels = design_multi_gc)

# Apply quasi-likelihood F test to incorporate Bayesian tagwise dispersion estimates as parameter for DEG analysis
dev_QLFT <- glmQLFTest(fit_gc,
                       contrast = con_Dev)

# Plot maternal logFC across logCPM (fdr < 0.05)
plotMD( dev_QLFT )

# How many significant DEGs? 4722
summary( decideTestsDGE( dev_QLFT, 
                         adjust.method = "fdr",
                         p.value = 0.05 ) )

# Filter for significance and logFC cutoff
dev_QLFT_cutoff <- topTags(dev_QLFT, 
                                n = (2205 + 2246), 
                                adjust.method = "fdr",
                                p.value = 0.05)

# Create df of logFC and sig cutoff DEGs (doubling of fold change or logFC of 1)
dev_QLFT_cutoff_df <- data.frame( dev_QLFT_cutoff$table )
dev_QLFT_fc_cutoff_df <- dev_QLFT_cutoff_df[ !( abs( dev_QLFT_cutoff_df$logFC ) < 1 ), ]

# Count total DEGs with logFC cutoff
nrow(dev_QLFT_cutoff_df) # Without logFC cutoff = 4451 DEGs
nrow(dev_QLFT_fc_cutoff_df) # With logFC cutoff = 222 DEGs

## Make Fig2B (MD plot)
# Create plotting df
dev_QLFT$table$Effect <- "Developmental"
parental_QLFT$table$Effect <- "Transgenerational"

dev_QLFT$table$FDR <- p.adjust(dev_QLFT$table$PValue, method = "fdr")
parental_QLFT$table$FDR <- p.adjust(parental_QLFT$table$PValue, method = "fdr")

QLFT <- rbind(dev_QLFT$table, parental_QLFT$table)
QLFT$Dir <- ifelse(QLFT$logFC > 0 & QLFT$FDR < 0.05, "Up", 
                             ifelse(QLFT$logFC < 0 & QLFT$FDR < 0.05,
                                    "Down", "None"))

QLFT$Effect = factor(
  QLFT$Effect,
  levels=c('Transgenerational','Developmental'))

QLFT$Dir = factor(
  QLFT$Dir,
  levels=c('Down','Up', 'None'))

Fig2B <- ggplot(data = QLFT,
                aes(x = logCPM, y = logFC, size = Dir, color = Dir)) +
  geom_point() +
  scale_size_manual(values = c(1, 1, .1), guide = "none") +
  scale_color_manual(values = c("blue", "red", "black"), guide = "none") +
  facet_grid(Effect~.) +
  theme_classic(base_rect_size = 0, base_size = 20)

Fig2B

# Compile Fig 2
Fig2 <- ggarrange(Fig2A, Fig2B, 
                   labels = c("A", "B"),
                   heights = c(1, 1),
                   widths = c(1, .5),
                   ncol = 2, nrow = 1, align = "hv")

Fig2

# Export Fig 5 as png
png("~/Documents/GitHub/Cross_pHox/Fig2.png", units = "in", width = 12, 
    height = 7, 
    res = 600)

Fig2

```

#Tests of transcriptional plasticity's adaptiveness

```{r}

# Create cpm df for regression against survival/morph data
logCPM_df <- as.data.frame(DGEList_log)

# Create tabularized df containing all replicates using 'melt'
logCPM_df$geneid <- row.names(logCPM_df)

tab_exp_df <- melt(logCPM_df,
                   id = c("geneid"))

# Add covariate information
# Create parental treatment variable
tab_exp_df$Par <- as.vector(sapply(tab_exp_df$variable, 
                       function(col) substr(col, 1, 1)))

# Create developmental treatment variable
tab_exp_df$Dev <- as.vector(gsub(".*_", "",
                     gsub("[0-9]", "", 
                          tab_exp_df$variable)))

# Add abnormality data
abnorm_df <- read.csv("Fitness_Data/Perc_Abnormality.csv")
abnorm_df$variable <- gsub("\\.", "", abnorm_df$variable)

tab_exp_df <- merge(tab_exp_df,
                    abnorm_df,
                    by = "variable")

## Add morph data
morph_parU <- read.table("Fitness_Data/data_parU.txt")
morph_parN <- read.table("Fitness_Data/data_parN.txt")

colnames(morph_parU) <- morph_parU[1,]
morph_parU <- morph_parU[-1, ]

colnames(morph_parN) <- morph_parN[1,]
morph_parN <- morph_parN[-1, ]

morph_df <- rbind(morph_parU, morph_parN)
morph_df$Length.spi <- as.numeric(morph_df$Length.spi)
morph_df$Length.bod <- as.numeric(morph_df$Length.bod)

# Calc mean morph values
spi_sum <- summarySE(measurevar = "Length.spi",
                     groupvars = "cultureFac",
                     data = morph_df)

bod_sum <- summarySE(measurevar = "Length.bod",
                     groupvars = "cultureFac",
                     data = morph_df)

morph_sum <- data.frame(variable = spi_sum$cultureFac,
                        Length.spi = spi_sum$Length.spi,
                        Length.bod = bod_sum$Length.bod)

tab_morph_df <- merge(tab_exp_df,
                    data.frame(variable = gsub("\\.", "", morph_sum$variable),
                               Length_spi = morph_sum$Length.spi,
                               Length_bod = morph_sum$Length.bod),
                    by = "variable")

# Reverse log^2 read count transformation
tab_exp_df$CPM <- 2^tab_exp_df$value
tab_morph_df$CPM <- 2^tab_morph_df$value
```

Estimate adaptiveness of plasticity in body size, spicule length

```{r}

# Wrangle phenotype data for selection gradient estimation
colnames(abnorm_df) <- c("cultureFac", "percAb")
morph_df$cultureFac <- gsub("\\.", "", morph_df$cultureFac)
morph_df$Spi_norm <- morph_df$Length.spi / morph_df$Length.bod

# Calculate mean spicule length and body length
remove_last_digit <- function(strings) {
  if (is.character(strings)) {
    without_last_digit <- substr(strings, 1, nchar(strings) - 1)
    return(without_last_digit)
  } else {
    stop("Input must be a character vector.")
  }
}

morph_df$cultureFac2 <- remove_last_digit(morph_df$cultureFac)
abnorm_df$cultureFac2 <- remove_last_digit(abnorm_df$cultureFac)

spi_sum <- summarySE(measurevar = "Spi_norm",
                     groupvars = c("treat_dev", "cultureFac", "cultureFac2", "Dam", "Sire"),
                     data = morph_df)

bod_sum <- summarySE(measurevar = "Length.bod",
                     groupvars = c("treat_dev", "cultureFac", "cultureFac2", "Dam", "Sire"),
                     data = morph_df)

# Merge abnorm data with summed performance df's
sel_grad_spi <- merge(spi_sum, abnorm_df, by = "cultureFac")
sel_grad_bod <- merge(bod_sum, abnorm_df, by = "cultureFac")

### Spicule length

# Create plasticity variables and merge into summed df's
sel_grad_spi_N <- dplyr::filter(sel_grad_spi, treat_dev == "N")
sel_grad_spi_U <- filter(sel_grad_spi, treat_dev == "U")

spi_pl <- unique(merge(
  data.frame(Sibship = gsub("_.*", "", sel_grad_spi_N$cultureFac2.x),
             N_spi = sel_grad_spi_N$Spi_norm),
  data.frame(Sibship = gsub("_.*", "", sel_grad_spi_U$cultureFac2.x),
             U_spi = sel_grad_spi_U$Spi_norm),
  by = "Sibship"))

spi_pl$Spi_pl <- spi_pl$U_spi - spi_pl$N_spi
sel_grad_spi$Sibship <- gsub("_.*", "", sel_grad_spi$cultureFac)
sel_grad_spi <- merge(sel_grad_spi, spi_pl, by = "Sibship")

# Create parental environment variable for sel grad models
sel_grad_spi$treat_par <- gsub("^(.).*", "\\1", sel_grad_spi$cultureFac)

### Body size

# Create plasticity variables and merge into summed df's
sel_grad_bod_N <- filter(sel_grad_bod, treat_dev == "N")
sel_grad_bod_U <- filter(sel_grad_bod, treat_dev == "U")

bod_pl <- unique(merge(
  data.frame(Sibship = gsub("_.*", "", sel_grad_bod_N$cultureFac2.x),
             N_bod = sel_grad_bod_N$Length.bod),
  data.frame(Sibship = gsub("_.*", "", sel_grad_bod_U$cultureFac2.x),
             U_bod = sel_grad_bod_U$Length.bod),
  by = "Sibship"))

bod_pl$Bod_pl <- bod_pl$U_bod - bod_pl$N_bod

sel_grad_bod$Sibship <- gsub("_.*", "", sel_grad_bod$cultureFac)
sel_grad_bod <- merge(sel_grad_bod, bod_pl, by = "Sibship")

# Create parental environment variable for sel grad models
sel_grad_bod$treat_par <- gsub("^(.).*", "\\1", sel_grad_bod$cultureFac)

# Fit beta distribution brm to accommodate dist of outcome variable
pedi <- read.csv("Pedigree/pedigree_sel.csv")
pedi_p <- prepPed(pedi)

relat_m <- as.matrix(makeA(pedi_p))

sel_grad_spi$ID <- sel_grad_spi$cultureFac2.x
sel_grad_bod$ID <- sel_grad_bod$cultureFac2.x


spi_sel_brm <- brm((percAb + 0.0001) ~ scale(Spi_norm) + scale(Spi_pl) +
                       treat_dev + treat_par + (1 | gr(ID, cov = relat_m)),
                data = sel_grad_spi,
                data2 = list(relat_m = relat_m),
                family = Beta(link = "logit"),
                chains = 4, cores = 2, iter = 40000)

spi_sel_brm2 <- brm((percAb + 0.0001) ~ scale(Spi_norm) + scale(Spi_pl) +
                       scale(Spi_norm):treat_dev + scale(Spi_pl):treat_dev +
                       treat_dev + treat_par + (1 | gr(ID, cov = relat_m)),
                data = sel_grad_spi,
                data2 = list(relat_m = relat_m),
                family = Beta(link = "logit"),
                chains = 4, cores = 2, iter = 40000)

spi_sel_brm3 <- brm((percAb + 0.0001) ~ scale(Spi_norm) + scale(Spi_pl) +
                       scale(Spi_norm):treat_par + scale(Spi_pl):treat_par +
                       treat_dev + treat_par + (1 | gr(ID, cov = relat_m)),
                data = sel_grad_spi,
                data2 = list(relat_m = relat_m),
                family = Beta(link = "logit"),
                chains = 4, cores = 2, iter = 40000)

bod_sel_brm3 <- brm((percAb + 0.0001) ~ scale(Length.bod) + scale(Bod_pl) +
                       scale(Length.bod):treat_par + scale(Bod_pl):treat_par +
                       treat_dev + treat_par + (1 | gr(ID, cov = relat_m)),
                data = sel_grad_bod,
                data2 = list(relat_m = relat_m),
                family = Beta(link = "logit"),
                chains = 4, cores = 2, iter = 40000)

posterior_summary(spi_sel_brm3)

pp_check(spi_sel_brm3)

posterior_summary(bod_sel_brm3)

pp_check(bod_sel_brm3)

# Plot raw biomin pl selection gradients
sel_grad_spi$percNorm <- 1- sel_grad_spi$percAb
sel_grad_bod$percNorm <- 1- sel_grad_bod$percAb

sel_grad_spi_sum <- summarySE(measurevar = "Spi_pl",
                              groupvars = c("treat_dev", 
                                            "treat_par","ID"),
                              data = sel_grad_spi)

sel_grad_bod_sum <- summarySE(measurevar = "Bod_pl",
                              groupvars = c("treat_dev", 
                                            "treat_par","ID"),
                              data = sel_grad_bod)


sel_grad_spi_summed <- summarySE(measurevar = "percNorm",
                              groupvars = c("treat_dev", 
                                            "treat_par","ID"),
                              data = sel_grad_spi)

sel_grad_bod_summed <- summarySE(measurevar = "percNorm",
                              groupvars = c("treat_dev", 
                                            "treat_par","ID"),
                              data = sel_grad_bod)

sel_grad_spi_sum$ID_dev <- paste(sel_grad_spi_sum$ID, 
                                 sel_grad_spi_sum$treat_dev,
                                 sep = "_")

sel_grad_bod_sum$ID_dev <- paste(sel_grad_bod_sum$ID, 
                                 sel_grad_bod_sum$treat_dev,
                                 sep = "_")

sel_grad_spi_sum <- merge(data.frame(ID_dev = paste(sel_grad_spi_summed$ID, 
                                 sel_grad_spi_summed$treat_dev,
                                 sep = "_"),
                                 percNorm = sel_grad_spi_summed$percNorm,
                                 percNorm_sd = sel_grad_spi_summed$sd),
                          sel_grad_spi_sum,
                          by = c("ID_dev"))

sel_grad_bod_sum <- merge(data.frame(ID_dev = paste(sel_grad_bod_summed$ID, 
                                 sel_grad_bod_summed$treat_dev,
                                 sep = "_"),
                                 percNorm = sel_grad_bod_summed$percNorm,
                                 percNorm_sd = sel_grad_bod_summed$sd),
                          sel_grad_bod_sum,
                          by = c("ID_dev"))

ggplot(data = sel_grad_spi_sum,
       aes(x = Spi_pl, y = percNorm, group = treat_dev, 
           color = treat_dev, fill = treat_dev)) +
  geom_errorbar(aes(ymin = percNorm - percNorm_sd, 
                    ymax = percNorm + percNorm_sd), 
                width = 0, size = 0.25, alpha = 0.5) +
  geom_errorbar(data = sel_grad_spi_sum,
                aes(xmin = Spi_pl - sd, xmax = Spi_pl + sd), 
                width = 0, size = 0.25, alpha = 0.5) +
  geom_point() +
  geom_smooth(data = sel_grad_spi, method = "lm") +
  facet_wrap(~treat_par) +
  theme_classic(base_rect_size = 0) +
  scale_color_manual(values = c("skyblue", "salmon2")) +
  scale_fill_manual(values = c("skyblue", "salmon2"), guide = "none") +
  labs(x = "Plasticity of biomineralization",
       y = "% normal development",
       color = "Dev. treatment")

# Plot raw body size pl selection gradient
ggplot(data = sel_grad_bod_sum,
       aes(x = Bod_pl, y = percNorm, group = treat_dev, 
           color = treat_dev, fill = treat_dev)) +
  geom_errorbar(aes(ymin = percNorm - percNorm_sd, 
                    ymax = percNorm + percNorm_sd), 
                width = 0, size = 0.25, alpha = 0.5) +
  geom_errorbar(data = sel_grad_bod_sum,
                aes(xmin = Bod_pl - sd, xmax = Bod_pl + sd), 
                width = 0, size = 0.25, alpha = 0.5) +
  geom_point() +
  geom_smooth(data = sel_grad_bod, method = "lm") +
  facet_wrap(~treat_par) +
  theme_classic(base_rect_size = 0) +
  scale_color_manual(values = c("skyblue", "salmon2")) +
  scale_fill_manual(values = c("skyblue", "salmon2"), guide = "none") +
  labs(x = "Plasticity of body length",
       y = "% normal development",
       color = "Dev. treatment")


```

```{r}

# Filter df's for dev DEGs
tab_dev_filt <- filter(tab_exp_df, geneid %in% row.names(dev_QLFT_cutoff_df))
tab_m_dev_filt <- filter(tab_morph_df, geneid %in% row.names(dev_QLFT_cutoff_df))

# Add sign of DE as variable (-1 or 1)
tab_dev_filt <- merge(tab_dev_filt,
                      data.frame(geneid = row.names(dev_QLFT_cutoff_df),
                         sign = ifelse(dev_QLFT_cutoff_df$logFC >1, 1, -1)),
                      by = "geneid")

tab_m_dev_filt <- merge(tab_m_dev_filt,
                      data.frame(geneid = row.names(dev_QLFT_cutoff_df),
                         sign = ifelse(dev_QLFT_cutoff_df$logFC >1, 1, -1)),
                      by = "geneid")

tab_morph_df <- merge(tab_morph_df,
                      data.frame(geneid = row.names(dev_QLFT$table),
                         sign = ifelse(dev_QLFT$table$logFC >1, 1, -1)),
                      by = "geneid")

# Scale CPM and transform it by units-toward-DE sign
tab_dev_filt$scCPM <- scale(tab_dev_filt$CPM)
tab_m_dev_filt$scCPM <- scale(tab_m_dev_filt$CPM)
tab_morph_df$scCPM<- scale(tab_morph_df$CPM)

tab_dev_filt$dirCPM <- tab_dev_filt$scCPM * tab_dev_filt$sign
tab_m_dev_filt$dirCPM <- tab_m_dev_filt$scCPM * tab_m_dev_filt$sign
tab_morph_df$dirCPM <- tab_morph_df$scCPM * tab_morph_df$sign


# Fit structural equation model: 
# (i) dev -> (1-abnorm), GE and (ii)  dev -> (1-abnorm)

# Fit abnorm SEM models - time = < 1 min
lm1s <- dlply(tab_dev_filt, c("geneid"), function(df) 
lm(dirCPM ~ Dev, data = df))

lm2s <- dlply(tab_dev_filt, c("geneid"), function(df) 
lm(PercAb ~ Dev + dirCPM, data = df))

## If dev treat contains NA coefficient, remove from lm1 and lm2
# First, convert lm's to coefficient df's
lm1_coefs <- list() 

for (i in 1:length(lm1s)) {
 lm1_coefs[[i]] <- as.data.frame(lm1s[[i]]$effects)[2,1]
}
names(lm1_coefs) <- names(lm1s)

lm2_coefs <- list() 

for (i in 1:length(lm2s)) {
 lm2_coefs[[i]] <- as.data.frame(lm2s[[i]]$effects)
}
names(lm2_coefs) <- names(lm2s)

lm1_pvals <- list() 

# Report significant DM exons

for (i in 1:length(lm1s)) {
 lm1_pvals[[i]] <- as.data.frame(anova(lm1s[[i]]))[1,5]
}
names(lm1_pvals) <- names(lm1s)

# Perform mediation analysis testing for adaptive differential expression
# e.g. DE results in greater fitness (less abnormality and high survival)

# Mediation of dev abnorm effect by gene expression - time = 1.5 hrs
dev_mediations <- list() # Create list to add vcov results to

for (i in 1:length(lm1s)) {
 tryCatch({dev_mediations[[i]] <- summary(mediate(lm1s[[i]], 
                                                  lm2s[[i]], 
                                                  sims = 1000, 
                                                  treat = "Dev", 
                                                  mediator = "dirCPM"))}, 
          error=function(e){})
}

names(dev_mediations) <- names(lm1s)

# Save and reload mediation
save(dev_mediations, file = "dev_mediations.Rdata")
```


```{r}
load("dev_mediations.Rdata")

# Filter for sig mediation: partition by + and - effects
# Extract p-values for indirect effects: E -> M -> GE
ind_p_d <- list() 

for (i in 1:length(dev_mediations)) {
 ind_p_d[[i]] <- dev_mediations[[i]]$d0.p 
}
names(ind_p_d) <- names(dev_mediations)

# Extract indirect effect confidence intervals
ind_ci_d <- list() 

for (i in 1:length(dev_mediations)) {
 ind_ci_d[[i]] <- data.frame(t(as.data.frame(dev_mediations[[i]]$d0.ci)))
}
names(ind_ci_d) <- names(dev_mediations)

ind_p_vd <- list() 

# Extract indirect effect estimates
ind_est_d <- list() 

for (i in 1:length(dev_mediations)) {
 ind_est_d[[i]] <- data.frame(t(as.data.frame(dev_mediations[[i]]$d0)))
}
names(ind_est_d) <- names(dev_mediations)

ind_est_d_df <- bind_rows(ind_est_d, .id = "column_label")

ind_p_vd <- list()

# Create df with geneid and indirect effect pvals
for (i in 1:length(ind_p_d)) {
 new_value_d <- as.numeric(ind_p_d[[i]])
 ind_p_vd <- c(ind_p_vd, new_value_d)
}

ind_ci_d_df <- bind_rows(ind_ci_d, .id = "column_label")

# Create df with geneid and indirect effect pvals
ind_p_dfd <- as.data.frame(t(data.frame(ind_p_vd)))

ind_p_dfd$fdr <- p.adjust(ind_p_dfd$V1, method = "fdr")

nrow(filter(ind_p_dfd, fdr < 0.05)) # 1421 / 4493 (16% of DE has mediated fitness effect)

# Filter to include only transcripts with significant mediation parameter estimate
sig_dev_meth_dfd <- filter(ind_ci_d_df, X2.5. > 0 & X97.5. > 0 | X2.5. < 0 & X97.5. < 0) # 66 mat indirect genes
nrow(sig_dev_meth_dfd)

# 32% of DE has mediated fitness effect
nrow(sig_dev_meth_dfd) / 4493

## Separate mediated genes based on +/- fitness effects
# What percent of fitness effects are adaptive? 33.15% or 471 genes
nrow(filter(sig_dev_meth_dfd, X2.5. < 0)) /
  nrow(sig_dev_meth_dfd)

## Plot fitness effects of differential expression
# Create plotting df
ind_df <- data.frame(geneid = ind_ci_d_df$column_label,
                     fit_eff = -1*ind_est_d_df$t.as.data.frame.dev_mediations..i...d0..,
                     ci_2.5 = -1*ind_ci_d_df$X2.5.,
                     ci_97.5 = -1*ind_ci_d_df$X2.5.)

ind_df <- merge(ind_df,
                data.frame(geneid = row.names(dev_QLFT_cutoff_df),
                           logFC = dev_QLFT_cutoff_df$logFC,
                           logCPM = dev_QLFT_cutoff_df$logCPM),
                by = "geneid")

ind_df$Dir <- ifelse(ind_df$fit_eff > 0, "Adaptive", "Maladaptive")

ggplot(data = ind_df,
       aes(y = abs(logFC), x = fit_eff)) +
  geom_point(aes(color = Dir), size = 0.25, alpha = 1) +
  geom_smooth(method = "lm", formula = y~poly(x,2), 
              alpha = 0.25, color = "black") +
  theme_classic() +
  scale_color_manual(values = c("royalblue1", "salmon1")) +
  labs(title = "DE's maladaptive effects were stronger than adaptive effects",
       subtitle = "All points represent DEGs",
       y = "Absolute logFC",
       x = "Fitness effect (abnormality)",
       color = "Effect")

```

```{r}
# Fit abnorm SEM models - time = < 1 min
lm3s <- dlply(na.omit(tab_m_dev_filt), c("geneid"), function(df) 
lm(dirCPM ~ Dev, data = df))

lm4s <- dlply(na.omit(tab_m_dev_filt), c("geneid"), function(df) 
lm(Length_spi ~ Dev + dirCPM, data = df))

## If dev treat contains NA coefficient, remove from lm1 and lm2
# First, convert lm's to coefficient df's
lm3_coefs <- list() 

for (i in 1:length(lm3s)) {
 lm3_coefs[[i]] <- as.data.frame(lm3s[[i]]$effects)[2,1]
}
names(lm3_coefs) <- names(lm3s)

lm4_coefs <- list() 

for (i in 1:length(lm4s)) {
 lm4_coefs[[i]] <- as.data.frame(lm4s[[i]]$effects)
}
names(lm4_coefs) <- names(lm4s)

lm3_pvals <- list() 

# Report significant DM exons

for (i in 1:length(lm3s)) {
 lm3_pvals[[i]] <- as.data.frame(anova(lm3s[[i]]))[1,5]
}
names(lm3_pvals) <- names(lm3s)

# Perform mediation analysis testing for adaptive differential expression
# e.g. DE results in greater fitness (less abnormality and high survival)

# Mediation of dev abnorm effect by gene expression - time = 1.5 hrs
dev_morph_mediations <- list() # Create list to add vcov results to

for (i in 1:length(lm3s)) {
 tryCatch({dev_morph_mediations[[i]] <- summary(mediate(lm3s[[i]], 
                                                  lm4s[[i]], 
                                                  sims = 1000, 
                                                  treat = "Dev", 
                                                  mediator = "dirCPM"))}, 
          error=function(e){})
}

names(dev_morph_mediations) <- names(lm3s)

# Save and reload mediation
save(dev_morph_mediations, file = "dev_morph_mediations.Rdata")

```

```{r}
load("dev_morph_mediations.Rdata")

# Filter for sig mediation: partition by + and - effects
# Extract p-values for indirect effects: E -> M -> GE
ind_p_dm <- list() 

for (i in 1:length(dev_morph_mediations)) {
 ind_p_dm[[i]] <- dev_morph_mediations[[i]]$d0.p 
}
names(ind_p_dm) <- names(dev_morph_mediations)

# Extract indirect effect confidence intervals
ind_ci_dm <- list() 

for (i in 1:length(dev_morph_mediations)) {
 ind_ci_dm[[i]] <- data.frame(t(as.data.frame(dev_morph_mediations[[i]]$d0.ci)))
}
names(ind_ci_dm) <- names(dev_morph_mediations)

ind_p_vdm <- list() 

# Extract indirect effect estimates
ind_est_dm <- list() 

for (i in 1:length(dev_morph_mediations)) {
 ind_est_dm[[i]] <- data.frame(t(as.data.frame(dev_morph_mediations[[i]]$d0)))
}
names(ind_est_dm) <- names(dev_morph_mediations)

ind_est_dm_df <- bind_rows(ind_est_dm, .id = "column_label")

ind_p_vdm <- list()

# Create df with geneid and indirect effect pvals
for (i in 1:length(ind_p_dm)) {
 new_value_dm <- as.numeric(ind_p_dm[[i]])
 ind_p_vdm <- c(ind_p_vdm, new_value_dm)
}

ind_ci_dm_df <- bind_rows(ind_ci_dm, .id = "column_label")

# Create df with geneid and indirect effect pvals
ind_p_dfdm <- as.data.frame(t(data.frame(ind_p_vdm)))

ind_p_dfdm$fdr <- p.adjust(ind_p_dfdm$V1, method = "fdr")

nrow(filter(ind_p_dfdm, fdr < 0.05)) # 1421 / 4493 (16% of DE has mediated fitness effect)

# Filter to include only transcripts with significant mediation parameter estimate
sig_dev_meth_dfdm <- filter(ind_ci_dm_df, X2.5. > 0 & X97.5. > 0 | X2.5. < 0 & X97.5. < 0) # 66 mat indirect genes
nrow(sig_dev_meth_dfdm)

# 32% of DE has mediated fitness effect
nrow(sig_dev_meth_dfdm) / 4493

## Separate mediated genes based on +/- fitness effects
# What percent of fitness effects are adaptive? 36.11% or 511 genes
nrow(filter(sig_dev_meth_dfdm, X2.5. > 0)) /
  nrow(sig_dev_meth_dfdm)

## Plot fitness effects of differential expression
# Create plotting df
ind_dfm <- data.frame(geneid = ind_ci_dm_df$column_label,
                     fit_eff = ind_est_dm_df$t.as.data.frame.dev_morph_mediations..i...d0..,
                     ci_2.5 = ind_ci_dm_df$X2.5.,
                     ci_97.5 = ind_ci_dm_df$X2.5.)

ind_dfm <- merge(ind_dfm,
                data.frame(geneid = row.names(dev_QLFT_cutoff_df),
                           logFC = dev_QLFT_cutoff_df$logFC,
                           logCPM = dev_QLFT_cutoff_df$logCPM),
                by = "geneid")

ind_dfm$Dir <- ifelse(ind_dfm$fit_eff > 0, "Adaptive", "Maladaptive")

ggplot(data = ind_dfm,
       aes(y = abs(logFC), x = fit_eff)) +
  geom_point(aes(color = Dir), size = 0.25, alpha = 1) +
  geom_smooth(method = "lm", formula = y~poly(x,2), 
              alpha = 0.25, color = "black") +
  theme_classic() +
  scale_color_manual(values = c("royalblue1", "salmon1")) +
  labs(title = "DE's maladaptive effects were stronger than adaptive effects",
       subtitle = "All points represent DEGs",
       y = "Absolute logFC",
       x = "Fitness effect (spicule length)",
       color = "Effect")

```

```{r}

# Fit abnorm SEM models - time = < 1 min
lm5s <- dlply(na.omit(tab_morph_df), c("geneid"), function(df) 
lm(dirCPM ~ Dev, data = df))

lm6s <- dlply(na.omit(tab_morph_df), c("geneid"), function(df) 
lm(Length_bod ~ Dev + dirCPM, data = df))

## If dev treat contains NA coefficient, remove from lm1 and lm2
# First, convert lm's to coefficient df's
lm5_coefs <- list() 

for (i in 1:length(lm5s)) {
 lm5_coefs[[i]] <- as.data.frame(lm5s[[i]]$effects)[2,1]
}
names(lm5_coefs) <- names(lm5s)

lm6_coefs <- list() 

for (i in 1:length(lm6s)) {
 lm6_coefs[[i]] <- as.data.frame(lm6s[[i]]$effects)
}
names(lm6_coefs) <- names(lm6s)

lm5_pvals <- list() 

# Report significant DM exons

for (i in 1:length(lm5s)) {
 lm5_pvals[[i]] <- as.data.frame(anova(lm5s[[i]]))[1,5]
}
names(lm5_pvals) <- names(lm5s)

# Perform mediation analysis testing for adaptive differential expression
# e.g. DE results in greater fitness (less abnormality and high survival)

# Mediation of dev abnorm effect by gene expression - time = 1.5 hrs
dev_bod_mediations <- list() # Create list to add vcov results to

for (i in 1:length(lm5s)) {
 tryCatch({dev_bod_mediations[[i]] <- summary(mediate(lm5s[[i]], 
                                                  lm6s[[i]], 
                                                  sims = 1000, 
                                                  treat = "Dev", 
                                                  mediator = "dirCPM"))}, 
          error=function(e){})
}

names(dev_bod_mediations) <- names(lm5s)

# Save and reload mediation
save(dev_bod_mediations, file = "dev_bod_mediations_all.Rdata")

```

```{r}

load("dev_bod_mediations_all.Rdata")

# Filter for sig mediation: partition by + and - effects
# Extract p-values for indirect effects: E -> M -> GE
ind_p_db <- list() 

for (i in 1:length(dev_bod_mediations)) {
 ind_p_db[[i]] <- dev_bod_mediations[[i]]$d0.p 
}
names(ind_p_db) <- names(dev_bod_mediations)

# Extract indirect effect confidence intervals
ind_ci_db <- list() 

for (i in 1:length(dev_bod_mediations)) {
 ind_ci_db[[i]] <- data.frame(t(as.data.frame(dev_bod_mediations[[i]]$d0.ci)))
}
names(ind_ci_db) <- names(dev_bod_mediations)

ind_p_vdb <- list() 

# Extract indirect effect estimates
ind_est_db <- list() 

for (i in 1:length(dev_bod_mediations)) {
 ind_est_db[[i]] <- data.frame(t(as.data.frame(dev_bod_mediations[[i]]$d0)))
}
names(ind_est_db) <- names(dev_bod_mediations)

ind_est_db_df <- bind_rows(ind_est_db, .id = "column_label")

ind_p_vdb <- list()

# Create df with geneid and indirect effect pvals
for (i in 1:length(ind_p_db)) {
 new_value_db <- as.numeric(ind_p_db[[i]])
 ind_p_vdb <- c(ind_p_vdb, new_value_db)
}

ind_ci_db_df <- bind_rows(ind_ci_db, .id = "column_label")

# Create df with geneid and indirect effect pvals
ind_p_dfdb <- as.data.frame(t(data.frame(ind_p_vdb)))

ind_p_dfdb$fdr <- p.adjust(ind_p_dfdb$V1, method = "fdr")

nrow(filter(ind_p_dfdb, fdr < 0.05)) # 1421 / 4493 (16% of DE has mediated fitness effect)

# Filter to include only transcripts with significant mediation parameter estimate
sig_dev_meth_dfdb <- filter(ind_ci_db_df, X2.5. > 0 & X97.5. > 0 | X2.5. < 0 & X97.5. < 0) # 66 mat indirect genes
nrow(sig_dev_meth_dfdb)

# 32% of DE has mediated fitness effect
nrow(sig_dev_meth_dfdb) / 4493

## Separate mediated genes based on +/- fitness effects
# What percent of fitness effects are adaptive? 36.11% or 511 genes
nrow(filter(sig_dev_meth_dfdb, X2.5. > 0)) /
  nrow(sig_dev_meth_dfdb)

## Plot fitness effects of differential expression
# Create plotting df
ind_dfb <- data.frame(geneid = ind_ci_db_df$column_label,
                     fit_eff = ind_est_db_df$t.as.data.frame.dev_bod_mediations..i...d0..,
                     ci_2.5 = ind_ci_db_df$X2.5.,
                     ci_97.5 = ind_ci_db_df$X2.5.)

ind_dfb <- merge(ind_dfb,
                data.frame(geneid = row.names(dev_QLFT$table),
                           logFC = dev_QLFT$table$logFC,
                           logCPM = dev_QLFT$table$logCPM),
                by = "geneid")

ind_dfb$Dir <- ifelse(ind_dfb$fit_eff > 0, "Adaptive", "Maladaptive")

ggplot(data = ind_dfb,
       aes(y = abs(logFC), x = fit_eff)) +
  geom_point(aes(color = Dir), size = 0.25, alpha = 1) +
  geom_smooth(method = "lm", formula = y~poly(x,2), 
              alpha = 0.25, color = "black") +
  theme_classic() +
  scale_color_manual(values = c("salmon1", "royalblue")) +
  labs(title = "DE's maladaptive effects were stronger than adaptive effects",
       subtitle = "All points represent DEGs",
       y = "Absolute logFC",
       x = "Fitness effect (body size)",
       color = "Effect")

```

#Animal models estimating heritability

```{r}

# Create experimental pedigree
pedi <- read.csv("Pedigree/pedigree_trimmed.csv")
pedi_p <- prepPed(pedi)

#  Read in metadata
meta_df <- read.csv("Pedigree/pedigree_meta.csv")

# Merge meta_df w/ CPM df
extractAllButLastCharacter <- function(inputString) {
  allButLast <- substring(inputString, 1, nchar(inputString) - 1)
  return(allButLast)
}

tab_exp_df$ID <- extractAllButLastCharacter(as.vector(tab_exp_df$variable))

tab_QG_df <- merge(tab_exp_df,
                   meta_df,
                   by = "ID")

tab_QG_df$ID <- paste(tab_QG_df$Dam, 
                      tab_QG_df$Sire, 
                      "_", 
                      tab_QG_df$Dev, 
                      sep = "")

tab_QG_df <- tab_QG_df %>% group_by(geneid) %>% mutate(CPM_sc = scale((CPM)))

# With nadiv, create a relatedness matrix
# Relatedness matrix is necessary for brms rather than inverse relatedness
relat_m <- as.matrix(makeA(pedi_p))

# Fit animal model using lme4qtl
lmer_test <- relmatLmer(CPM_sc ~ Par + Dev + (1|ID) + (1|Dam) + (1|Sire),
                            data = filter(tab_QG_df, geneid == "rna-XM_030973936.1"),
                            relmat = list(ID = relat_m))

# Print evolvability estimate
VarProp(lmer_test)[1,6]

# Turn this into a for loop and apply to all DE genes
#  Next, estimat heritability of plasticity First, create df of plasticity per genotype - 1 min
tab_QG_filt <- filter(tab_QG_df, geneid %in% row.names(dev_QLFT_cutoff_df))

lme4qtls <- dlply(tab_QG_df, c("geneid"), function(df) 
relmatLmer(CPM_sc ~ Par + Dev + (1|ID) + (1|Dam) + (1|Sire),
                            data = df,
                            relmat = list(ID = relat_m)))

# With for loop, export evolvability values for each gene
evol_exp <- list()

for (i in 1:length(lme4qtls)) {
 evol_exp[[i]] <- VarProp(lme4qtls[[i]])[1,6] 
}

names(evol_exp) <- names(lme4qtls)

lme4qtl_exp_evol_df <- as.data.frame(
  unlist(
    bind_rows(evol_exp,
              .id = "column_label")))

# Plot distribution of expression heritability for DE genes
ggplot(data = lme4qtl_exp_evol_df,
       aes(x = `unlist(bind_rows(evol_exp, .id = "column_label"))`)) +
  geom_density(fill = "grey") +
  labs(x = "Evolvability", title = "Evolvability of expression for DEGs")

## Fit animal models for plasticity of expression rather than expression
# Estimate DE per sibship and add to df
tab_QG_df$Sibship_geneid <- paste(gsub("_.*", "", tab_QG_df$ID),
                                   tab_QG_df$geneid,
                                   sep = "_")

tab_DevN <- filter(tab_QG_df, Dev == "N")
tab_DevU <- filter(tab_QG_df, Dev == "U")

Sib_FC_df <- merge(
  data.frame(Sibship_geneid = tab_DevN$Sibship_geneid,
                       CPM_N = tab_DevN$CPM),
  data.frame(Sibship_geneid = tab_DevU$Sibship_geneid,
             CPM_U = tab_DevU$CPM),
  by = "Sibship_geneid")

Sib_FC_df$Sib_FC <- log(Sib_FC_df$CPM_U/Sib_FC_df$CPM_N, 
                        base = exp(2))

tab_pl_df <- merge(tab_QG_df,
                    data.frame(Sibship_geneid = Sib_FC_df$Sibship_geneid,
                               Sib_FC = Sib_FC_df$Sib_FC),
                    by = "Sibship_geneid")

tab_pl_filt <- filter(tab_pl_df, geneid %in% row.names(dev_QLFT_cutoff_df))
tab_pl_df <- tab_pl_df %>% group_by(geneid) %>% mutate(Sib_FC_sc = scale(Sib_FC))

pl_lme4s <- dlply(tab_pl_df, c("geneid"), function(df) 
relmatLmer(Sib_FC_sc ~ Par + (1|ID) + (1|Dam) + (1|Sire),
                            data = df,
                            relmat = list(ID = relat_m)))

# With for loop, export plasticity evolvability values for each gene
evol_pl <- list()

for (i in 1:length(pl_lme4s)) {
 evol_pl[[i]] <- VarProp(pl_lme4s[[i]])[1,6] 
}

names(evol_pl) <- names(pl_lme4s)

lme4qtl_pl_evol_df <- as.data.frame(
  unlist(
    bind_rows(evol_pl,
              .id = "column_label")))

# Plot distribution of expression heritability for DE genes
ggplot(data = lme4qtl_pl_evol_df,
       aes(x = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  geom_density(fill = "grey") +
  labs(x = "Evolvability", title = "Evolvability of DE for DEGs")

# Plot correlation of h2 for expression and DE with histogram on border
lme4qtl_exp_evol_df$geneid <- row.names(lme4qtl_exp_evol_df)
lme4qtl_pl_evol_df$geneid <- row.names(lme4qtl_pl_evol_df)

pl_exp_corr <- ggplot(data = merge(lme4qtl_exp_evol_df,
                    lme4qtl_pl_evol_df,
                    by = "geneid"),
                    aes(y = `unlist(bind_rows(evol_pl, .id = "column_label"))`,
           x = `unlist(bind_rows(evol_exp, .id = "column_label"))`)) +
  geom_point(size = 0.5) +
  theme_classic() +
  labs(x = expression("Expression " ~ italic(I[A])),
       y = expression("DE " ~ italic(I[A])))

```

```{r}

# Plot the scatter plot with marginal histograms
pl_exp_corr <- ggMarginal(pl_exp_corr, type = "histogram", fill = "skyblue")
pl_exp_corr

## Plot and model associations between DE's heritability and fitness effect
# Create df of pl h2 and abnorm fitness effect per gene
plh2_v_abnorm <- merge(ind_df, lme4qtl_pl_evol_df, by = "geneid")

ggplot(data = plh2_v_abnorm,
       aes(x = fit_eff, 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  #geom_point(size = 0.5, color = "black") +
  geom_smooth(method = "loess", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  labs(x = "Fitness effect of DE (abnormality)", y = "DE IA")

plh2_v_spi <- merge(ind_dfm, lme4qtl_pl_evol_df, by = "geneid")

ggplot(data = plh2_v_spi,
       aes(x = fit_eff, 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  #geom_point(size = 0.5, color = "black") +
  geom_smooth(method = "loess", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  labs(x = "Fitness effect of DE (spicule length)", y = "DE IA")

plh2_v_bod <- merge(ind_dfb, lme4qtl_pl_evol_df, by = "geneid")

ggplot(data = plh2_v_bod,
       aes(x = fit_eff, 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  #geom_point(size = 0.5, color = "black") +
  geom_smooth(method = "loess", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  labs(x = "Fitness effect of DE (body size)", y = "DE IA")
  
## Remake plots but filter for significant fitness effects
ggplot(data = filter(plh2_v_abnorm, geneid %in% sig_dev_meth_dfd$column_label),
       aes(x = abs(fit_eff), 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  geom_point(size = 1, color = "black") +
  geom_smooth(method = "loess", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  facet_wrap(~Dir) +
  labs(x = "Fitness effect of DE (abnormality)", y = "DE IA")

ggplot(data = filter(plh2_v_spi, geneid %in% sig_dev_meth_dfdm$column_label),
       aes(x = abs(fit_eff), 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  geom_point(size = 1, color = "black") +
  geom_smooth(method = "lm", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  facet_wrap(~Dir) +
  labs(x = "Fitness effect of DE (spicule length)", y = "DE IA")

ggplot(data = filter(plh2_v_bod, geneid %in% sig_dev_meth_dfdb$column_label),
       aes(x = abs(fit_eff), 
           y = `unlist(bind_rows(evol_pl, .id = "column_label"))`)) +
  geom_point(size = 1, color = "black") +
  geom_smooth(method = "lm", alpha = 0.25) +
  theme_classic(base_rect_size = 0) +
  labs(x = "Fitness effect of DE (body size)", y = "DE IA")

# Density plots of evolvability
ggplot(data = filter(plh2_v_abnorm, geneid %in% sig_dev_meth_dfd$column_label),
       aes(y = `unlist(bind_rows(evol_pl, .id = "column_label"))`,
           group = Dir, fill = Dir, x = Dir)) +
  geom_boxplot() +
  theme_classic() +
  labs(y = expression("Differential Expression " ~ italic(I[A])),
       x = "Abnormality effect")

ggplot(data = filter(plh2_v_spi, geneid %in% sig_dev_meth_dfdm$column_label),
       aes(y = `unlist(bind_rows(evol_pl, .id = "column_label"))`,
           group = Dir, fill = Dir, x = Dir)) +
  geom_boxplot() +
  theme_classic() +
  labs(y = expression("Differential Expression " ~ italic(I[A])),
       x = "Spicule effect")

Fig5A<- ggplot(data = filter(plh2_v_bod, geneid %in% sig_dev_meth_dfdb$column_label),
       aes(y = `unlist(bind_rows(evol_pl, .id = "column_label"))`,
           group = Dir, fill = Dir, x = Dir)) +
  geom_boxplot() +
  theme_classic() +
  scale_fill_manual(values = c("salmon1", "royalblue"), guide = "none") +
  labs(y = expression("Differential Expression " ~ italic(I[A])),
       x = "Body size effect")

Fig5A
  
# Model significance of difference in IA between adaptive/maladaptive DE
size_brm_df <- filter(plh2_v_bod, geneid %in% sig_dev_meth_dfdb$column_label)
size_brm_df <- size_brm_df %>% 
    rename_with(.cols = 8, ~ "IA")

size_brm_df$IA_beta <- size_brm_df$IA + .000001

size_brm <- brm(IA_beta ~ Dir,
                data = size_brm_df,
                family = Beta(link = "logit"),
                chains = 4, cores = 1, iter = 40000)

size_cont_brm <- brm(IA_beta ~ Dir:scale(abs(fit_eff)),
                data = size_brm_df,
                family = Beta(link = "logit"),
                chains = 4, cores = 1, iter = 40000)

posterior_summary(size_cont_brm)

plot(size_brm)

# Assemble Fig5
h2_eff_df <- data.frame(Dir = c("Adaptive", "Maladaptive"),
                        h2_eff = c(-274.525055,14.690865),
                        h2_eff_2.5 = c(-480.410936, -92.105131),
                        h2_eff_97.5 = c(-71.708541, 117.610374))

Fig5B <- ggplot(data = h2_eff_df,
                aes(y = h2_eff, x = Dir, color = Dir)) +
  geom_hline(yintercept = 0, lty = 2, color = "gray") +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = h2_eff_2.5, ymax = h2_eff_97.5),
                width = 0, size = .75) +
  theme_classic() +
  scale_color_manual(values = c("salmon1", "royalblue"), guide = "none") +
  labs(y = expression("DE " ~ italic(I[A]) ~ "/ absolute body size effect"),
       x = "Body size effect")

Fig5B

Fig5 <- ggarrange(Fig5A, Fig5B, 
                   labels = c("A", "B"),
                   heights = c(1, 1),
                   widths = c(1, 1),
                   ncol = 2, nrow = 1, align = "hv")

Fig5

```

#Multivariate animal model for measuring correlation between genes' DE

```{r}

# Create df with column of CPMs for each gene
test_df <- tab_pl_filt %>%
  pivot_wider(id_cols = c(ID, Par, Dev, Sire, Dam), 
              names_from = geneid, 
              values_from = Sib_FC)

lmer_mv <- relmatLmer(Sib_FC ~ Par + (0 + geneid|ID) + (1|Dam) + (1|Sire),
                      data = filter(tab_pl_filt,
                                    geneid == c("gene-LOC100893164",
                                                "gene-LOC105442818",
                                                "gene-LOC115918257",
                                                "gene-LOC115920372",
                                                "gene-LOC115918620",
                                                "gene-LOC115921788")),
                      relmat = list(ID = relat_m))

# Print evolvability estimate
VarCorr(lmer_mv)

```

#Functional enrichment analyses

First, wrangle GO annotation data for tests

```{r}

# Read in genomic ranges object of Spur5.0 gene GO terms
BP <- readRDS("GO_annotation/bp_spurpuratus_eg_gene_go_genesets.rds")
CC <- readRDS("GO_annotation/cc_spurpuratus_eg_gene_go_genesets.rds")
MF <- readRDS("GO_annotation/mf_spurpuratus_eg_gene_go_genesets.rds")

## Create df containing cols for geneid, BP, CC, and MF
# Combine GO lists and export genes
all_GOs <- c(BP, CC, MF)
unique_genes <- unique(unlist(all_GOs))

# Create an empty data frame with columns for each grouping variable
GOannot_df <- data.frame(Gene = unique_genes, BP = "", CC = "", MF = "", stringsAsFactors = FALSE)

# Iterate over the grouping variables and populate the data frame
for (group_var in names(BP)) {
  # Get the vector of gene names for the current grouping variable
  gene_vector <- BP[[group_var]]
  
  # Set the grouping variable for genes that belong to it
  GOannot_df$BP[GOannot_df$Gene %in% gene_vector] <- paste(GOannot_df$BP[GOannot_df$Gene %in% gene_vector], group_var, sep = ", ")
}

for (group_var in names(CC)) {
  gene_vector <- CC[[group_var]]
  GOannot_df$CC[GOannot_df$Gene %in% gene_vector] <- paste(GOannot_df$CC[GOannot_df$Gene %in% gene_vector], group_var, sep = ", ")
}

for (group_var in names(MF)) {
  gene_vector <- MF[[group_var]]
  GOannot_df$MF[GOannot_df$Gene %in% gene_vector] <- paste(GOannot_df$MF[GOannot_df$Gene %in% gene_vector], group_var, sep = ", ")
}

# Remove leading and trailing commas
GOannot_df$BP <- gsub("^, |, $", "", GOannot_df$BP)
GOannot_df$CC <- gsub("^, |, $", "", GOannot_df$CC)
GOannot_df$MF <- gsub("^, |, $", "", GOannot_df$MF)

# Show resulting df
head(GOannot_df)

## Merge geneID w/ transcriptIDs for use w/ RNAseq dfs
# Read in Spur_5.0 gff3
Spur5.0_gff <- read.gff(
  "Genome_Resources/GCF_000002235.5_Spur_5.0_genomic.gff"
  )

Spur5.0_gff_tr <- filter(Spur5.0_gff, type == "mRNA")

# Create df of transcript ID and geneID
gene_name_index <- data.frame(
  Gene = gsub(";.*", "",
              gsub(".*Parent=", "", Spur5.0_gff_tr$attributes)),
  Transcript = gsub(";.*", "",
              gsub("ID=", "", Spur5.0_gff_tr$attributes))
)

gene_name_index$Gene <- gsub("gene-", "", gene_name_index$Gene)

# How many gene names are in the GO term df? Most of them! Good start
nrow(filter(gene_name_index, Gene %in% GOannot_df$Gene))

# Format GOannot_df for GOMWU + Fisher's exact tests
GOannot_df <- merge(GOannot_df,
                    gene_name_index,
                    by = "Gene")

goAnnot_spur5.0 <- data.frame(
  ID = GOannot_df$Transcript,
  GO = paste(gsub(",", ";", GOannot_df$BP),
             gsub(",", ";", GOannot_df$CC),
             gsub(",", ";", GOannot_df$MF),
             sep = ";"))

# Clean up GO term list
goAnnot_spur5.0$GO <- gsub(";;", ";", goAnnot_spur5.0$GO)

remove_1st_semi <- function(text_vector) {
  modified_text_vector <- vector(length = length(text_vector))
  
  for (i in 1:length(text_vector)) {
    if (substr(text_vector[i], 1, 1) == ";") {
      modified_text_vector[i] <- substr(text_vector[i], 2, nchar(text_vector[i]))
    } else {
      modified_text_vector[i] <- text_vector[i]
    }
  }
  
  return(modified_text_vector)
}

remove_last_semi <- function(text_vector) {
  modified_text_vector <- vector(length = length(text_vector))
  
  for (i in 1:length(text_vector)) {
    if (substr(text_vector[i], nchar(text_vector[i]), nchar(text_vector[i])) == ";") {
      modified_text_vector[i] <- substr(text_vector[i], 1, nchar(text_vector[i]) - 1)
    } else {
      modified_text_vector[i] <- text_vector[i]
    }
  }
  
  return(modified_text_vector)
}

# Apply function to remove first semicolons from GO term list
goAnnot_spur5.0$GO <- gsub(" ", "", remove_last_semi(remove_1st_semi(goAnnot_spur5.0$GO)))

# Export to GOMWU directory
write.table(goAnnot_spur5.0, 
            "GO_MWU-master/goAnnot_spur5.0.tab",
            quote = FALSE,
            sep = '\t',
            col.names = FALSE,
            row.names = FALSE)

```

Next, perform analyses

```{r}

# Create DE -log pvalue + logFC GOMWU inputs
write.csv(
  data.frame(geneid = row.names(dev_QLFT$table),
             neg_log_p = -log(dev_QLFT$table$PValue)),
  row.names = FALSE,
  "GO_MWU-master/dev_logFC.csv")

write.csv(
  data.frame(geneid = row.names(dev_QLFT$table),
             logFC = (dev_QLFT$table$logFC)),
  row.names = FALSE,
  "GO_MWU-master/dev_logFC.csv")

# Create fitness effect for GOMWU
write.csv(
  data.frame(geneid = ind_dfb$geneid,
             eff = ind_dfb$fit_eff),
  row.names = FALSE,
  "GO_MWU-master/bod_GOMWU_eff.csv")

write.csv(
  data.frame(geneid = plh2_v_bod$geneid,
             eff_IA = plh2_v_bod$fit_eff * plh2_v_bod$`unlist(bind_rows(evol_pl, .id = "column_label"))`),
  row.names = FALSE,
  "GO_MWU-master/bod_IA_GOMWU_eff.csv")

```


```{r}

# GO enrichments using Mann Whitney U tests
setwd("~/Documents/GitHub/Cross_pHox/GO_MWU-master/")

#Now we multiply them together into a new column

## Ok we also want to bring in our annotations
#I would suggest putting a GO_MWU folder into your working directory for these steps. There is some stuff to download such as the obo files 
#See https://github.com/z0on/GO_MWU

# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.
# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 
# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.
# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.
# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.
# Stretch the plot manually to match tree to text

# Mikhail V. Matz, UT Austin, February 2015; matz@utexas.edu

################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.

# Edit these to match your data file names: 
input="bod_GOMWU_eff.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="goAnnot_spur5.0.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="MF" # either MF, or BP, or CC
source("gomwu.functions.R")

# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1, # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=25,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.25) # # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           #	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
# do not continue if the printout shows that no GO terms pass 10% FDR.

quartz.save(file = "quartz.png", type = "png")
results=gomwuPlot(input, goAnnotations, goDivision,
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
	absValue=.5,
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
	level2=0.001, # FDR cutoff to print in regular (not italic) font.
	level3=0.0001, # FDR cutoff to print in large bold font.
	txtsize=.75,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
	treeHeight=0.5, # height of the hierarchical clustering tree
	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed
)
# manually rescale the plot so the tree matches the text 
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.  

# text representation of results, with actual adjusted p-values
results

# Export list of GO terms enriched among genes in lowest quartiles of TSS acess and expression
write.csv(results[1], 
          "Dev_GOMWU_results.csv", 
          row.names = TRUE)


# Search for p53 TF in dev DEG's
peek <- dev_QLFT$table
peek$geneid <- row.names(peek)

# Find geneids of ribotoxicity response transcripts
goAnnot <- read.table("GO_MWU-master/goAnnot_spur5.0.tab")
dev_QLFT_cutoff_df$geneid <- row.names(dev_QLFT_cutoff)

colnames(goAnnot) <- c("geneid", "GO_terms")

dev_QLFT_cutoff_df <- merge(dev_QLFT_cutoff_df,
                         goAnnot,
                         by = "geneid")

## Maladaptive ribosomal GO terms
# RNA dependent ATPase = 
# LOC581723/UPF1 (responsive to oxidative stress)

```

```{r}

# Try functional enrichment with topGO
library(topGO)
bg_genes <- row.names(dev_QLFT$table)
 
# Read in genes of interest
candidate_list <- row.names(dev_QLFT_cutoff$table)


```

#Boneyard

Selection gradient model rather than structural eq. model for performance effect

```{r}

## Fit selection gradient models

ab_lmm_df <- filter(tab_exp_df, geneid %in% tab_dev_filt$geneid)
ab_lmm_df$Sibship <- gsub("_.*", "", ab_lmm_df$variable)

# Fit selection gradient models
ab_lms <- dlply(ab_lmm_df, c("geneid"), function(df) 
lm(PercAb ~ Par + Dev + value + abs(Sib_FC), data = df))

ab_lm_coefs <- list() 

# Extract plasticity's fitness effects and p-values
for (i in 1:length(ab_lms)) {
 ab_lm_coefs[[i]] <- as.data.frame(ab_lms[[i]]$coefficients)[5,1]
}
names(ab_lm_coefs) <- names(ab_lms)

ab_lm_pvals <- list() 

# Report significant effects
for (i in 1:length(ab_lms)) {
 ab_lm_pvals[[i]] <- as.data.frame(anova(ab_lms[[i]]))[4,5]
}
names(ab_lm_pvals) <- names(ab_lms)

ab_lm_coefs_df <- as.data.frame(unlist(bind_rows(ab_lm_coefs, 
                                                 .id = "variable")))
ab_lm_coefs_df$variable <- row.names(ab_lm_coefs_df)

ab_lm_pvals_df <- as.data.frame(unlist(bind_rows(ab_lm_pvals, 
                                                 .id = "variable")))
ab_lm_pvals_df$variable <- row.names(ab_lm_pvals_df)

ab_lm_df <- merge(ab_lm_coefs_df, ab_lm_pvals_df, by = "variable")

ab_lm_df$FDR <- p.adjust(ab_lm_df$`unlist(bind_rows(ab_lm_pvals, .id = "variable"))`,
                         method = "fdr")

# How many significant fittnes effects? 9% of DEGs
nrow(filter(ab_lm_df, FDR < 0.05))/nrow(ab_lm_df)

## Plot absolute DE by fitness effect
# Create plotting df
selg_ab_pl_df <- merge(data.frame(geneid = row.names(dev_QLFT_cutoff_df),
                                       logFC = dev_QLFT_cutoff_df$logFC),
                       data.frame(geneid = ab_lm_df$variable,
                                  Abnorm_eff = ab_lm_df$`unlist(bind_rows(ab_lm_coefs, .id = "variable"))`,
                                  FDR = ab_lm_df$FDR),
                       
                       by = "geneid")

selg_ab_pl_df$Dir <- ifelse(selg_ab_pl_df$Abnorm_eff < 0, "Adaptive", "Maladaptive")

# Plot
ggplot(data = filter(selg_ab_pl_df),
       aes(y = abs(logFC), x = Abnorm_eff)) +
  geom_point(aes(color = Dir), size = 0.25, alpha = 1) +
  geom_smooth(method = "lm", formula = y ~ poly(x,2), 
              alpha = 0.25, color = "black") +
  theme_classic() +
  scale_color_manual(values = c("royalblue1", "salmon1")) +
  labs(title = "DE's maladaptive effects were stronger than adaptive effects",
       subtitle = "All points represent DEGs",
       y = "Absolute logFC",
       x = "Fitness effect (abnormality)",
       color = "Effect")


```

